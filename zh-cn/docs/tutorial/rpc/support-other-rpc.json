{
  "filename": "support-other-rpc.md",
  "__html": "<h1 id=\"%E6%89%A9%E5%B1%95%E6%94%AF%E6%8C%81\">扩展支持 <a class=\"header-anchor\" href=\"#%E6%89%A9%E5%B1%95%E6%94%AF%E6%8C%81\">#</a></h1>\n<p>当前支持微服务框架有dubbo、openfeign、grpc，开发者如果使用其他的框架并且同时也遇到分布式事务场景，可以参考以下内容。</p>\n<h2 id=\"%E6%89%A9%E5%B1%95%E6%B5%81%E7%A8%8B\">扩展流程 <a class=\"header-anchor\" href=\"#%E6%89%A9%E5%B1%95%E6%B5%81%E7%A8%8B\">#</a></h2>\n<p>支持新的RPC框架只需解决事件上下文传递问题即可。\n这里以我们<a href=\"/zh-cn/docs/tutorial/rpc/openfeign.html\">openfeign</a>的支持为例进行说明。</p>\n<h3 id=\"%E8%B0%83%E7%94%A8%E6%96%B9%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87\">调用方如何发送事件上下文 <a class=\"header-anchor\" href=\"#%E8%B0%83%E7%94%A8%E6%96%B9%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87\">#</a></h3>\n<p><strong>定义拦截器FeignInterceptor</strong>，实现openfeign调用的拦截。 代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FeignInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">RequestInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TransactionContextSerializer transactionContextSerializer = <span class=\"hljs-keyword\">new</span> TransactionContextSerializer();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">apply</span><span class=\"hljs-params\">(RequestTemplate requestTemplate)</span> </span>{\n        Annotation annotation = requestTemplate.methodMetadata().method().getAnnotation(EnableTcc<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n        <span class=\"hljs-keyword\">if</span> (annotation != <span class=\"hljs-keyword\">null</span> &amp;&amp; TransactionContextHolder.getCurrentTransactionContext() != <span class=\"hljs-keyword\">null</span>) {\n            requestTemplate.header(TransactionContextConstants.TRANSACTION_CONTEXT,\n                    Base64.getEncoder().encodeToString(transactionContextSerializer.serialize(TransactionContextHolder.getCurrentTransactionContext())));\n        }\n\n        <span class=\"hljs-keyword\">return</span>;\n    }\n}\n</code></pre>\n<p><strong>被拦截的FeignClient</strong>，以下代码来源于<a href=\"https://github.com/changmingxie/tcc-transaction/tree/master-2.x/tcc-transaction-tutorial-sample/tcc-transaction-http-sample\">tcc-transaction-http-sample</a></p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@FeignClient</span>(name = <span class=\"hljs-string\">\"capital\"</span>, url = <span class=\"hljs-string\">\"http://localhost:8082/tcc-transaction-http-capital/\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CapitalFeignClient</span> </span>{\n\n    <span class=\"hljs-meta\">@EnableTcc</span>\n    <span class=\"hljs-meta\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/tradeOrder/record\"</span>, method = RequestMethod.POST)\n    <span class=\"hljs-meta\">@ResponseBody</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">record</span><span class=\"hljs-params\">(@RequestBody CapitalTradeOrderDto tradeOrderDto)</span></span>;\n}\n\n</code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>tcc接口上必现添加@EnableTcc</li>\n</ul>\n<blockquote>\n<p>1、ConfigurableCoordinatorAspect识别@EnableTcc，执行添加事件参与方，并保存分支事件上下文到TransactionContextHolder中</p>\n<p>2、feign拦截器内部识别此注解才传递事件上下文，避免无效传递。</p>\n</blockquote>\n<ul>\n<li>事件上下文为了实现隐式传递，一般放到header(http)或attachment(dubbo)里，不同框架不一样。</li>\n<li>事件上下文序列化后再传递。</li>\n</ul>\n<h3 id=\"%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E4%BA%8B%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87\">服务如何接收事件上下文 <a class=\"header-anchor\" href=\"#%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E4%BA%8B%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87\">#</a></h3>\n<p><strong>web服务端拦截</strong>，实现如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RequesterInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HandlerInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TransactionContextSerializer transactionContextSerializer = <span class=\"hljs-keyword\">new</span> TransactionContextSerializer();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">preHandle</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n\n        String transactionContext = request.getHeader(TransactionContextConstants.TRANSACTION_CONTEXT);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNotEmpty(transactionContext)) {\n            TransactionContextHolder.setCurrentTransactionContext(transactionContextSerializer.deserialize(Base64.getDecoder().decode(transactionContext)));\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterCompletion</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        String transactionContext = request.getHeader(TransactionContextConstants.TRANSACTION_CONTEXT);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNotEmpty(transactionContext)) {\n            TransactionContextHolder.clear();\n        }\n    }\n}\n</code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>从header中取出事件上下文，并进行反序列化</li>\n<li>取出的事件上下文，放到TransactionContextHolder中，请求结束时从TransactionContextHolder清理事件上下文。</li>\n</ul>\n",
  "link": "/zh-cn/docs/tutorial/rpc/support-other-rpc.html",
  "meta": {}
}